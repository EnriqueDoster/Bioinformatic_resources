


library(dplyr)
library(tibble)

#AMR
getwd()

setwd("/Users/gaire/Desktop/training_swine_fecal_resistome")
list.files()



# read metadata, sequencing output from AMR++ pipeline, and merged into single metadata file
metadata <- read.csv('./data/metadata.csv')
head(metadata)
dim(metadata)

# now reads sequencing output from AMR++ pipeline, and merged into single metadata file
trimmomatic_data <- read.csv('./data/trimmomatic_stats.csv')
host_removal_data <- read.csv('./data/host_removal_stats.csv')
head(trimmomatic_data)
head(host_removal_data)

#combined these trimmomatic_data, host_removal_data into metadata 
#each data has same ID column (first column), so we need merged by this ID 

# First merge trimmomatic_data with host_removal_data
combined_data_temp <- merge(trimmomatic_data, host_removal_data, by = c("ID", "SampleName"), all = TRUE)

# Then merge the result with metadata
combined_metadata <- merge(metadata, combined_data_temp, by = c("ID", "SampleName"), all = TRUE)


#----------------------------------------------------------------------------------------------
# now read AMR count matrix from AMR++ pipeline v2.0
amr_count_matrix = read.csv('./data/AMR_analytic_matrix_gene_feces.csv', row.names = 1)  # load amr count metrices
colnames(amr_count_matrix) <- sub('X','',colnames(amr_count_matrix))  # remove xinfront of sample name
megares_annotation_file = read.csv('./data/megares_full_annotations_v2.00.csv', row.names = 1) # AMR megares database annotation file 
dim(amr_count_matrix)


#now we need to create a phyloseq to process these data, phyloseq req amr_count_matrix, taxa_table which is megares_annotation_file
# and metadata

amr_count_matrix <- amr_count_matrix
megares_annotation_file <- megares_annotation_file
sample_metadata_df <- combined_metadata%>%column_to_rownames(var = "ID") # formating metadata for phyloseq



amr.ps <- merge_phyloseq(otu_table(amr_count_matrix,taxa_are_rows = T), 
                                             phyloseq::tax_table(as.matrix(megares_annotation_file)), 
                                             sample_data(sample_metadata_df))

amr.ps
#phyloseq-class experiment-level object
#otu_table()   OTU Table:         [ 3434 taxa and 219 samples ]
#sample_data() Sample Data:       [ 219 samples by 23 sample variables ]
#tax_table()   Taxonomy Table:    [ 3434 taxa by 4 taxonomic ranks ]

otu_df <- data.frame(otu_table(amr.ps))
write.csv(otu_df, "otu_df.csv")
# now removed amr genes that requried SNP confirmation
#snp_confirmation_amr= megares_annotation_file[grepl("RequiresSNPConfirmation",row.names(megares_annotation_file)),]
#snp_confirmation_arg=unique(snp_confirmation_amr$group)
#amr_snpfilter.ps <-  phyloseq::subset_taxa(amr.ps, !group%in%snp_confirmation_arg)

# Identify the rows that do not contain "RequiresSNPConfirmation"
rows_to_keep <- !grepl("RequiresSNPConfirmation", row.names(otu_table(amr.ps)))
# Subset the otu_table to keep only the rows that do not contain "RequiresSNPConfirmation"
otu_table(amr.ps) <- otu_table(amr.ps)[rows_to_keep,]
amr_snpfilter.ps = amr.ps
sample_data(amr_snpfilter.ps)$raw_amr_count <- sample_sums(amr_snpfilter.ps) # calculate number of total resistome counts per samples


# 3434-357
#357
#78
#> amr_snpfilter.ps
#phyloseq-class experiment-level object
#otu_table()   OTU Table:         [ 3077 taxa and 219 samples ]
#sample_data() Sample Data:       [ 219 samples by 24 sample variables ]
#tax_table()   Taxonomy Table:    [ 3077 taxa by 4 taxonomic ranks ]
#rank_names(amr_snpfilter.ps)

#saveRDS(amr_snpfilter.ps, "./data/amr_snpfilter.ps.rds")




#now look at basic QC -- number of raw reads, proportion of host and non-host reads, and how many raw reads aligned to resistome


#Q.1 raw reads by sample and negative controls 
if (!requireNamespace("dplyr", quietly = TRUE)) {
  install.packages("dplyr")
}
library(dplyr)


sample_metadata<- data.frame(sample_data(amr_snpfilter.ps))
# Calculate total, mean, median, and range of NumberOfInputReads by SampleType by Millions
summary_stats <- sample_metadata %>%
  group_by(SampleType) %>%
  dplyr::summarize(
    TotalNumberOfInputReads = sum(NumberOfInputReads/1e6, na.rm = TRUE),
    MeanNumberOfInputReads = mean(NumberOfInputReads/1e6, na.rm = TRUE),
    MedianNumberOfInputReads = median(NumberOfInputReads/1e6, na.rm = TRUE),
    RangeOfInputReads = paste0(min(NumberOfInputReads/1e6, na.rm = TRUE), "-", max(NumberOfInputReads/1e6, na.rm = TRUE))
  )
print(summary_stats)

#Calculate total, mean, median, and range of mean quality score





#plot the distribution of raw read generated by treatment group (exclude Mock", "NegCtl" sampletype)
raw_reads_bytrt.plt <- 
  ggplot(sample_metadata%>%filter(!SampleType %in% c("Mock", "NegCtl")), 
         aes(x = TreatmentGroup, y = NumberOfInputReads / 1e6)) +
  geom_boxplot() +
  labs(
    title = "Distribution of Raw Reads by Treatment Group",
    x = "Treatment Group",
    y = "Number of Input Reads (Millions)"
  ) +
  theme_classic()
raw_reads_bytrt.plt                      
                       
# run stat models to see if there any difference in average raw reads between treatment group [remember mutiple pig samples were taken from same pen]


# plot the proportion of host and non-host reads by treatment group
# Calculate the proportion of mapped and unmapped reads

sample_metadata <- sample_metadata %>%
  mutate(
    TotalReads = Mapped + Unmapped,
    MappedProp = Mapped / TotalReads,
    UnmappedProp = Unmapped / TotalReads
  ) %>%
  filter(!SampleType %in% c("Mock", "NegCtl")) %>% 
  gather(key = "Type", value = "Proportion", MappedProp, UnmappedProp)

# Create the stacked bar plot
ggplot(sample_metadata, aes(x = SampleName, y = Proportion, fill = Type)) +
  geom_bar(stat = "identity") +
  labs(
    title = "Proportion of host(mapped) and \nnon-host (Unmapped) Reads by Sample",
    x = "Sample Name",
    y = "Proportion of Reads"
  ) +
  facet_wrap(~ TreatmentGroup, scales="free_x") +
  theme_minimal() +
  theme(axis.text.x = element_blank())
  
# Q-- calculated mean and range of proprtion by treatment groups


# how many raw reads aligned to resistome counts -- calculate summary statistics
# for this you need to first divided raw_amr_count/NumberOfInputReads

sample_metadata <- sample_metadata %>%
  mutate(proportion_AMR_reads = raw_amr_count / NumberOfInputReads)

# Group by TreatmentGroup and calculate summary statistics
proportion_AMR_reads_summary_stats <- sample_metadata %>%
  filter(!SampleType %in% c("Mock", "NegCtl")) %>% # Exclude "Mock" and "NegCtl" sample types
  dplyr::summarize(
    Mean = mean(proportion_AMR_reads, na.rm = TRUE),
    Median = median(proportion_AMR_reads, na.rm = TRUE),
    Range = paste0(min(proportion_AMR_reads, na.rm = TRUE), "-", max(proportion_AMR_reads, na.rm = TRUE))
  )
proportion_AMR_reads_summary_stats



# now calculated how many unique group (AMR gene group (i.e. ARGs)), mechanisms, class found in each treatment groups and is there any differences

# Extract sample data
amr_snpfilter_long_format <- psmelt(amr_snpfilter.ps)


# Display the summary statistics
# Calculate summary statistics for unique ARGs, mechanisms, and classes
arg_summary_stats <- amr_snpfilter_long_format
 
# Filter data to include only rows with Abundance > 0
arg_summary_stats <- amr_snpfilter_long_format %>%
  filter(Abundance > 0)

# Calculate summary statistics for unique ARGs, mechanisms, and classes
arg_summary_stats <- arg_summary_stats %>%
  dplyr::summarize(
    Total_Unique_ARGs = n_distinct(group),
    Total_Unique_Mechanisms = n_distinct(mechanism),
    Total_Unique_Classes = n_distinct(class)
   )
arg_summary_stats


# calculated alpha diversity (i.e richness, Shannon diversity at class,mechanism and group level) and plot by treatment groups
# test if these values difference between treatment group

# resistome alpha diversity
arg_grp.ps= tax_glom(amr_snpfilter.ps, "group") 
arg_mech.ps= tax_glom(amr_snpfilter.ps, "mechanism") 
arg_class.ps= tax_glom(amr_snpfilter.ps, "class") 

# estimate diversity
arg_grp_tab <-microbiome::alpha(arg_grp.ps, index = c("observed", "Shannon", "evenness_pielou"))
arg_mech_tab <-microbiome::alpha(arg_mech.ps, index = c("observed", "Shannon", "evenness_pielou"))
arg_class_tab <-microbiome::alpha(arg_class.ps, index = c("observed", "Shannon", "evenness_pielou"))



knitr::kable(head(arg_grp_tab))
knitr::kable(head(arg_mech_tab))    
knitr::kable(head(arg_class_tab))    


sample_metadata <- sample_metadata

sample_metadata$richness_arg_grp <- arg_grp_tab$observed 
sample_metadata$shannon_arg_grp <- arg_grp_tab$diversity_shannon
sample_metadata$evenness_arg_grp <- arg_grp_tab$evenness



sample_metadata$richness_mech <- arg_mech_tab$observed 
sample_metadata$shannon_mech <- arg_mech_tab$diversity_shannon 
sample_metadata$evenness_mech <- arg_mech_tab$evenness



sample_metadata$richness_class<- arg_class_tab$observed 
sample_metadata$shannon_class <- arg_class_tab$diversity_shannon 
sample_metadata$evenness_class <- arg_class_tab$evenness


# now plot richness, shannon diversity by treatment group

arg_richness_bytrt.plt <- 
  ggplot(sample_metadata%>%filter(!SampleType %in% c("Mock", "NegCtl")), 
         aes(x =as.factor(Age_dpw) , y = richness_arg_grp, color=TreatmentGroup)) +
  geom_boxplot() + ylim(0, 300)+
  theme_classic()
arg_richness_bytrt.plt        

arg_richness_bytrt.plt <- 
  ggplot(sample_metadata%>%filter(!SampleType %in% c("Mock", "NegCtl")), 
         aes(x =TreatmentGroup , y = richness_arg_grp, color=TreatmentGroup)) +
  geom_boxplot() + 
  ylim(0, 300)+
  theme_classic()
arg_richness_bytrt.plt       




# is overall AMR classes is difference between treatment group? is samples are clustered togher? what about mechanisms and ARG level
# first lets look at all feces, negative and positive control and then without negative controls
#one sample is outlier removed that
arg_class_fil.ps <- subset_samples(arg_class.ps, !SampleName=="NPB_F10_2_F6_S16")
amr_class_ord <- ordinate(arg_class_fil.ps, "NMDS", "bray")
amr_class_ord.plt = plot_ordination(arg_class_fil.ps, amr_class_ord, type="samples", color="SampleType", title="SampleType")+
                   #geom_polygon(aes(fill=SampleType), alpha=0.2) + 
                   geom_point(size=2)+theme_bw()
amr_class_ord.plt



#now remove controls and performed by treatment groups, but its good ideas to first normalized this count matrics
arg_class_fil.ps <- subset_samples(arg_class.ps, !SampleName=="NPB_F10_2_F6_S16")
arg_class_fil.ps <- subset_samples(arg_class_fil.ps, !SampleType %in% c("Mock", "NegCtl"))

# Function to perform CSS normalization
normalize_css <- function(physeq) {
  # Transform phyloseq object to metagenomeSeq object
  mseq_obj <- phyloseq_to_metagenomeSeq(physeq)
  # Perform CSS normalization
  mseq_obj <- metagenomeSeq::cumNorm(mseq_obj)
  # Get the normalized counts
  norm_counts <- metagenomeSeq::MRcounts(mseq_obj, norm = TRUE, log = FALSE)
  # Replace the counts in the phyloseq object with normalized counts
  otu_table(physeq) <- otu_table(norm_counts, taxa_are_rows = TRUE)
  return(physeq)
}

#  phyloseq object is named arg_class.ps
arg_class_css_norm.ps <- normalize_css(arg_class_fil.ps)

# Check the resulting normalized phyloseq object
arg_class_css_norm.ps
#otu_table(arg_class_css_norm.ps)

#sample_data(arg_class_css_norm.ps)$Age_dpw <- as.factor(sample_data(arg_class_css_norm.ps)$Age_dpw )

amr_class_ord <- ordinate(arg_class_css_norm.ps, "NMDS", "bray")
amr_class_ord.plt = plot_ordination(arg_class_css_norm.ps, amr_class_ord, type="samples", color="TreatmentGroup", title="TreatmentGroup")+
  #geom_polygon(aes(fill=SampleType), alpha=0.2) + 
  geom_point(size=2)+theme_bw()
 
amr_class_ord.plt

# test

#how about by amr mechanism and ARG group age?







# which AMR classes is most abundant between treatment groups?


# Summarize by class as example
ps.rel = transform_sample_counts(arg_class_css_norm.ps, function(x) x/sum(x)*100)
ps.melt <- psmelt(ps.rel)
# change to character for easy-adjusted level
ps.melt$class <- as.character(ps.melt$class)

ps.melt <- ps.melt %>%
  group_by(TreatmentGroup, class) %>%
  mutate(mean=mean(Abundance))
# select group mean > 1
keep <- unique(ps.melt$class[ps.melt$mean > 1])
ps.melt$class[!(ps.melt$class %in% keep)] <- "Others"
#to get the same rows together
ps.melt_sum <- ps.melt %>%
  group_by(Sample,TreatmentGroup,class) %>%
  summarise(Abundance=sum(Abundance))

ggplot(ps.melt_sum, aes(x = Sample, y = Abundance, fill = class)) + 
  geom_bar(stat = "identity", aes(fill=class)) + 
  labs(x="", y="Relative abudnance (%)") +
  facet_wrap(~TreatmentGroup, scales= "free_x", nrow=1) +
  theme_classic() + 
  ggthemes::scale_fill_tableau()+
  theme(strip.background = element_blank(), 
        axis.text.x.bottom = element_blank())

unique(amr_class_long$class)
# Aggregate by AMR class
class_abundance <- amr_class_long %>%
  group_by(Sample, class) %>%
  dplyr::summarize(Total_Abundance = sum(Abundance, na.rm = TRUE)) %>%
  ungroup()

# Identify the top 10 most abundant classes
top_classes <- class_abundance %>%
  group_by(class) %>%
  dplyr::summarize(Total_Abundance = sum(Total_Abundance)) %>%
  top_n(10, Total_Abundance) 
 



# can you run stat model to see which is ARGs is differences between treatment groups -- as examples
#  phyloseq object is named arg_class.ps
#https://www.yanh.org/2021/01/01/microbiome-r/
arg_group_fil.ps <- subset_samples(arg_grp.ps, !SampleName=="NPB_F10_2_F6_S16")
arg_group_fil.ps <- subset_samples(arg_group_fil.ps, !SampleType %in% c("Mock", "NegCtl"))
arg_group_css_norm.ps <- normalize_css(arg_group_fil.ps)

# Define the unique groups
arg_group_css_norm_melt <- psmelt(arg_group_css_norm.ps)
unique_group <- unique(arg_group_css_norm_melt$group)

# Initialize a list to store the results
results_list <- list()

# Filter data based on abundance >= 10
filtered_data <- arg_group_css_norm_melt %>% filter(Abundance >= 10)

# Calculate the percentage of samples for each group
group_counts <- filtered_data %>%
  group_by(group) %>%
  dplyr::summarize(count = n(), total = n_distinct(filtered_data$Sample)) %>%
  mutate(percentage = count / total * 100)

# Filter groups that are present in at least 50% of all samples
valid_groups <- group_counts %>%
  filter(percentage >= 50) %>%
  pull(group) %>%
  unique()

# Filter the main dataset to include only valid groups
filtered_data <- filtered_data %>% filter(group %in% valid_groups)

unique(filtered_data$group)

# Initialize a list to store the results
results_list <- list()

# Loop through each group and perform the analysis
for (group in valid_groups) {
  # Filter the data for the current group
  group_data <- filtered_data %>% filter(group == group)
  
  # Log-transform the abundance
  group_data$log10_Abundance <- log10(group_data$Abundance)
  
  # Fit the linear mixed model
  lmm <- lmer(log10_Abundance ~ TreatmentGroup + (1 | PenID), data = group_data)
  
  # Perform pairwise comparisons
  emmeans_results <- emmeans(lmm, pairwise ~ TreatmentGroup)
  
  # Extract and adjust p-values for multiple comparisons (BH)
  contrasts <- as.data.frame(emmeans_results$contrasts)
  contrasts$adj_p.value <- p.adjust(contrasts$p.value, method = "BH")
  
  # Store the results in the list
  results_list[[group]] <- list(
    model = lmm,
    emmeans = as.data.frame(emmeans_results$emmeans),
    contrasts = contrasts
  )
  
  # Write results to CSV
  #write.csv(results_list[[group]]$emmeans, paste0("emmeans_", group, ".csv"))
  #write.csv(results_list[[group]]$contrasts, paste0("contrasts_", group, ".csv"))
}

# Plot the estimated marginal means for each group
emmeans_df <- do.call(rbind, lapply(names(results_list), function(group) {
  df <- results_list[[group]]$emmeans
  df$group <- group
  df
}))

ggplot(emmeans_df, aes(x = TreatmentGroup, y = emmean, fill = TreatmentGroup)) +
  geom_point() +
  geom_errorbar(aes(ymin = emmean - SE, ymax = emmean + SE), width = 0.2) +
  facet_wrap(~ group,  nrow=3) + ylim(NA, 2.8)+
  labs(
    title = "Estimated Marginal Means of Log10 Abundance by Group and Treatment Group",
    x = "Treatment Group",
    y = "Estimated Marginal Mean Log10 Abundance"
  ) +
  theme_bw()

# Plot the pairwise comparisons for each group
contrasts_df <- do.call(rbind, lapply(names(results_list), function(group) {
  df <- results_list[[group]]$contrasts
  df$group <- group
  df
}))







